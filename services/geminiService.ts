import { GoogleGenAI, Type, Modality } from "@google/genai";
import { Source, TrendingTopic, AICampaignPlan, GeneratedAsset } from "../types";

const API_KEY = process.env.API_KEY;

// Utility to get a fresh AI client. Crucial for Veo which needs the latest key.
const getAiClient = () => {
    const key = process.env.API_KEY;
    if (!key) {
        console.warn("API_KEY environment variable not set. Gemini API calls will use mock data.");
        return null;
    }
    return new GoogleGenAI({ apiKey: key });
};

const systemInstruction = `You are an AI assistant for a civic engagement platform called 'Digital Democracy'. Your tone must be neutral, informative, and encouraging of constructive dialogue. Avoid partisan language, speculation, or inflammatory statements. When generating a post based on a topic, rely on the provided search results to ensure accuracy.`;


// --- EXISTING FUNCTIONS (Refactored to use getAiClient) ---

export const generatePostContent = async (topic?: string): Promise<{ text: string; sources: Source[] }> => {
  const ai = getAiClient();
  // ... (rest of the function is the same, just uses the locally scoped 'ai' instance)
  const prompt = topic 
    ? `Write a positive and engaging social media post for a political campaign about: "${topic}"`
    : `Write a positive and engaging social media post for a political campaign about improving local communities.`;
  
  if (!ai) {
    console.log("Using mock response due to missing API key.");
    return new Promise(resolve => setTimeout(() => {
        resolve({
          text: `This is a mock AI-generated post about "${topic || 'local communities'}". In a real scenario, this would be generated by the Gemini model, grounded in real-time search results for accuracy and credibility.`,
          sources: [
            { title: "Mock Source 1: Community News", uri: "#" },
            { title: "Mock Source 2: City Council Report", uri: "#" }
          ]
        });
    }, 1000));
  }

  try {
    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash',
      contents: prompt,
      config: {
        systemInstruction,
        tools: [{googleSearch: {}}],
      }
    });

    const text = response.text;
    const groundingMetadata = response.candidates?.[0]?.groundingMetadata;
    
    let sources: Source[] = [];
    if (groundingMetadata?.groundingChunks) {
      sources = groundingMetadata.groundingChunks
        .filter(chunk => chunk.web)
        .map(chunk => ({
          title: chunk.web.title,
          uri: chunk.web.uri,
        }));
    }

    if (text) {
      return { text: text.trim(), sources };
    } else {
      throw new Error("Received an empty response from Gemini API.");
    }
  } catch (error) {
    console.error("Error generating content with Gemini:", error);
    throw new Error("Failed to generate content from Gemini API.");
  }
};

export const generateImageFromDescription = async (description: string): Promise<string | null> => {
    // This function is now superseded by generatePremiumImage, but kept for the JSON upload feature
    const ai = getAiClient();
    const prompt = `Generate a visually appealing image for a social media post. The image should be a realistic, high-quality photo representing the following concept: "${description}"`;

    if (!ai) {
        console.log("Using mock image response due to missing API key.");
        return new Promise(resolve => setTimeout(() => {
            resolve(`https://picsum.photos/seed/${encodeURIComponent(description.slice(0,10))}/800/400`);
        }, 1500));
    }

    try {
        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash-image',
            contents: {
                parts: [{ text: prompt }],
            },
            config: {
                responseModalities: [Modality.IMAGE],
            },
        });

        for (const part of response.candidates[0].content.parts) {
            if (part.inlineData) {
                const base64ImageBytes: string = part.inlineData.data;
                const mimeType = part.inlineData.mimeType;
                return `data:${mimeType};base64,${base64ImageBytes}`;
            }
        }
        throw new Error("No image data found in response.");

    } catch (error) {
        console.error("Error generating image with Gemini:", error);
        return null;
    }
};

export const generateCreatorSpotlight = async (): Promise<{ quote: string; author: string; }> => {
  const ai = getAiClient();
  const prompt = `You are an AI for a civic engagement platform. Generate a short, powerful, and inspirational quote about one of the following topics: civic duty, community building, leadership, positive change, or the power of a single voice. The quote should be under 200 characters. Also, provide the name of a historical figure, philosopher, or an anonymous source (e.g., 'Ancient Proverb') to attribute the quote to.`;
  
  if (!ai) {
    return new Promise(resolve => setTimeout(() => {
        resolve({
          quote: "The future is built by the hands of those who show up.",
          author: "A wise mock philosopher"
        });
    }, 800));
  }

  try {
    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash',
      contents: prompt,
      config: {
        responseMimeType: "application/json",
        responseSchema: {
          type: Type.OBJECT,
          properties: {
            quote: { type: Type.STRING, description: "The inspirational quote." },
            author: { type: Type.STRING, description: "The author or source of the quote." }
          },
          required: ["quote", "author"]
        }
      }
    });

    const jsonText = response.text.trim();
    const data = JSON.parse(jsonText);
    
    if (data.quote && data.author) {
      return data;
    } else {
      throw new Error("Received invalid JSON structure from Gemini API.");
    }

  } catch (error) {
    console.error("Error generating creator spotlight with Gemini:", error);
    throw new Error("Failed to generate creator spotlight from Gemini API.");
  }
};

export const generateTrendingTopics = async (): Promise<TrendingTopic[]> => {
  const ai = getAiClient();
  const prompt = `Generate a list of 5 current, realistic trending topics for a social media platform focused on civic engagement and politics. For each topic, provide a category (e.g., "National Politics", "Community", "Technology"), the topic title, and a fictional but realistic post count.`;

  if (!ai) {
    return [];
  }

  try {
    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash',
      contents: prompt,
      config: {
        systemInstruction: "You are an AI assistant for 'Digital Democracy'. You generate trending topics. Your tone must be neutral and informative. Avoid partisan language.",
        responseMimeType: "application/json",
        responseSchema: {
          type: Type.OBJECT,
          properties: {
            topics: {
              type: Type.ARRAY,
              items: {
                type: Type.OBJECT,
                properties: {
                  category: { type: Type.STRING },
                  topic: { type: Type.STRING },
                  postCount: { type: Type.NUMBER },
                },
                required: ["category", "topic", "postCount"],
              },
            },
          },
          required: ["topics"],
        },
      },
    });

    const jsonText = response.text.trim();
    const data = JSON.parse(jsonText);

    if (data.topics && Array.isArray(data.topics)) {
      return data.topics;
    } else {
      throw new Error("Received invalid JSON structure for trending topics from Gemini API.");
    }
  } catch (error) {
    console.error("Error generating trending topics with Gemini:", error);
    throw new Error("Failed to generate trending topics from Gemini API.");
  }
};

// --- NEW AI CREATOR STUDIO FUNCTIONS ---

export const generateCampaignWithThinking = async (prompt: string): Promise<AICampaignPlan> => {
    const ai = getAiClient();
    if (!ai) {
        console.log("Using mock campaign response due to missing API key.");
        return new Promise(resolve => setTimeout(() => {
            resolve({
                postText: `This is a mock campaign plan about "${prompt}". Gemini Pro would generate a comprehensive strategy here, including text, hashtags, and visual ideas.`,
                hashtags: ["#MockCampaign", "#AI", "#CivicTech"],
                visuals: [
                    { description: "An inspiring photo of diverse community members working together.", type: 'image' },
                    { description: "A short, energetic video montage of city improvements.", type: 'video' },
                ],
            });
        }, 2000));
    }

    const MAX_RETRIES = 3;
    const INITIAL_DELAY_MS = 2000;

    for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
        try {
            const response = await ai.models.generateContent({
                model: "gemini-2.5-pro",
                contents: `Analyze the following user request and generate a strategic content plan for a social media post on the 'Digital Democracy' platform. The plan should be in a valid JSON object format. User request: "${prompt}"`,
                config: {
                    systemInstruction: "You are a world-class campaign strategist. Your goal is to generate a complete, actionable social media content plan based on user requests. The output must be a single JSON object with the keys 'postText', 'hashtags' (an array of strings), and 'visuals' (an array of objects, each with 'description' and 'type' which can be 'image' or 'video').",
                    responseMimeType: "application/json",
                    thinkingConfig: { thinkingBudget: 32768 },
                },
            });

            const jsonText = response.text.trim();
            return JSON.parse(jsonText); // Success!
        } catch (error: any) {
            console.error(`Error generating campaign (Attempt ${attempt}/${MAX_RETRIES}):`, error);
            const errorString = JSON.stringify(error);
            const isRetryable = errorString.includes("503") || errorString.includes("UNAVAILABLE") || errorString.includes("overloaded");

            if (isRetryable && attempt < MAX_RETRIES) {
                const delay = INITIAL_DELAY_MS * Math.pow(2, attempt - 1); // Exponential backoff
                console.log(`Model is overloaded. Retrying in ${delay}ms...`);
                await new Promise(resolve => setTimeout(resolve, delay));
            } else {
                // On last attempt or if it's not a retryable error, throw a user-friendly error.
                throw new Error("Failed to generate campaign plan. The model may be temporarily overloaded. Please try again in a few moments.");
            }
        }
    }
     // This part should be unreachable if MAX_RETRIES > 0, but is a fallback.
    throw new Error("Failed to generate campaign plan after multiple retries.");
};

export const generatePremiumImage = async (prompt: string, aspectRatio: '1:1' | '16:9' | '9:16'): Promise<string> => {
    const ai = getAiClient();
    if (!ai) {
        console.log("Using mock premium image due to missing API key.");
        const seed = aspectRatio === '1:1' ? 'sq' : aspectRatio === '16:9' ? 'ls' : 'pt';
        return new Promise(resolve => setTimeout(() => {
             resolve(`https://picsum.photos/seed/${seed}${encodeURIComponent(prompt.slice(0,5))}/1024/1024`);
        }, 1500));
    }
    
    try {
        const response = await ai.models.generateImages({
            model: 'imagen-4.0-generate-001',
            prompt: prompt,
            config: {
              numberOfImages: 1,
              outputMimeType: 'image/jpeg',
              aspectRatio: aspectRatio,
            },
        });

        const base64ImageBytes: string = response.generatedImages[0].image.imageBytes;
        return `data:image/jpeg;base64,${base64ImageBytes}`;

    } catch(error) {
        console.error("Error generating premium image with Imagen 4:", error);
        throw new Error("Failed to generate premium image from Gemini API.");
    }
};

export const editImage = async (base64ImageData: string, prompt: string): Promise<string> => {
    const ai = getAiClient();
    if (!ai) {
        console.log("Using mock image edit due to missing API key.");
        // Just return the original image with a delay to simulate an API call
        return new Promise(resolve => setTimeout(() => resolve(base64ImageData), 1000));
    }
    
    const mimeType = base64ImageData.substring(base64ImageData.indexOf(":") + 1, base64ImageData.indexOf(";"));
    const data = base64ImageData.split(',')[1];

    try {
        const response = await ai.models.generateContent({
          model: 'gemini-2.5-flash-image',
          contents: {
            parts: [
              { inlineData: { data, mimeType } },
              { text: prompt },
            ],
          },
          config: {
              responseModalities: [Modality.IMAGE],
          },
        });

        for (const part of response.candidates[0].content.parts) {
            if (part.inlineData) {
                const newBase64: string = part.inlineData.data;
                const newMimeType = part.inlineData.mimeType;
                return `data:${newMimeType};base64,${newBase64}`;
            }
        }
        throw new Error("No edited image data found in response.");
        
    } catch(error) {
        console.error("Error editing image:", error);
        throw new Error("Failed to edit image with Gemini API.");
    }
};

export const generateVideo = async (prompt: string, aspectRatio: '16:9' | '9:16'): Promise<string> => {
    // Veo needs its own client instance right before the call to ensure the latest key is used.
    const ai = getAiClient(); 
    if (!ai) {
        console.log("Using mock video due to missing API key.");
        return new Promise(resolve => setTimeout(() => resolve('https://www.w3schools.com/html/mov_bbb.mp4'), 5000));
    }

    try {
        let operation = await ai.models.generateVideos({
            model: 'veo-3.1-fast-generate-preview',
            prompt: prompt,
            config: {
                numberOfVideos: 1,
                resolution: '720p',
                aspectRatio: aspectRatio
            }
        });

        while (!operation.done) {
            // Poll every 10 seconds
            await new Promise(resolve => setTimeout(resolve, 10000));
            operation = await ai.operations.getVideosOperation({ operation: operation });
        }

        const downloadLink = operation.response?.generatedVideos?.[0]?.video?.uri;
        if (!downloadLink) {
            throw new Error("Video generation succeeded but no download link was found.");
        }
        
        // Fetch the video as a blob and create a local URL to avoid CORS/API key issues in the video tag
        const apiKey = process.env.API_KEY;
        const response = await fetch(`${downloadLink}&key=${apiKey}`);
        if (!response.ok) {
            throw new Error(`Failed to download the generated video. Status: ${response.status}`);
        }
        const videoBlob = await response.blob();
        return URL.createObjectURL(videoBlob);
        
    } catch(error: any) {
        console.error("Error generating video with Veo:", error);
        // Error from Gemini API is often a complex object. Stringifying it helps reliably search for status codes.
        const errorString = JSON.stringify(error);
        
        if (errorString.includes("RESOURCE_EXHAUSTED") || errorString.includes("429")) {
            throw new Error("You have exceeded your video generation quota. Please check your plan and billing details. For more information, visit ai.google.dev/gemini-api/docs/rate-limits.");
        }
        
        // Handle the specific API key error for Veo
        if (error instanceof Error && error.message.includes("Requested entity was not found.")) {
             throw new Error("API key is not valid for Veo. Please select a valid key.");
        }
        
        throw new Error("Failed to generate video from Gemini API. An unexpected error occurred.");
    }
};